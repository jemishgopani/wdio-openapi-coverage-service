/**
 * @jest-environment node
 */
import { describe, expect, test, beforeAll, afterAll } from '@jest/globals';
import fs from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'node:url';
import OpenAPICoverageService from '../../src/index.js';
import { apiClient } from '../../src/index.js';
import type { Browser } from 'webdriverio';

// Get directory path for ES modules
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Path to test OpenAPI spec
const OPENAPI_PATH = path.join(__dirname, '../fixtures/openapi.json');
const OUTPUT_PATH = path.join(__dirname, '../fixtures/wdio-integration-report.json');

// Mock WebdriverIO environment to test parallel execution scenarios
describe('OpenAPI Coverage Service WebdriverIO Integration', () => {
  beforeAll(() => {
    // Clean up previous test report if it exists
    if (fs.existsSync(OUTPUT_PATH)) {
      fs.unlinkSync(OUTPUT_PATH);
    }
  });

  afterAll(() => {
    // Delete the test report
    if (fs.existsSync(OUTPUT_PATH)) {
      fs.unlinkSync(OUTPUT_PATH);
    }
  });

  test('should coordinate between multiple workers', async () => {
    // Simulate worker 0-0 (first worker - main)
    process.env.WDIO_WORKER_ID = '0-0';

    const options = {
      openApiPath: OPENAPI_PATH,
      outputPath: OUTPUT_PATH,
      logLevel: 'silent',
    };

    // Create first worker service
    const worker1Service = new OpenAPICoverageService(options as any, {}, options as any);

    // Initialize the first worker
    await worker1Service.before({}, [], {} as Browser);

    // Make API calls from first worker
    try {
      await apiClient.get('https://jsonplaceholder.typicode.com/users');
    } catch (_e) {
      // Ignore errors
    }

    // Simulate worker 0-1 (second parallel worker)
    process.env.WDIO_WORKER_ID = '0-1';

    // Create second worker service
    const worker2Service = new OpenAPICoverageService(options as any, {}, options as any);

    // Initialize the second worker
    await worker2Service.before({}, [], {} as Browser);

    // Make different API calls from second worker
    try {
      await apiClient.get('https://jsonplaceholder.typicode.com/users/1');
    } catch (_e) {
      // Ignore errors
    }

    // Finalize both workers
    await worker2Service.after(0, {}, []);

    // Switch back to main worker for final report generation
    process.env.WDIO_WORKER_ID = '0-0';
    await worker1Service.after(0, {}, []);

    // Verify the report was generated by the main worker
    expect(fs.existsSync(OUTPUT_PATH)).toBe(true);

    // Read and parse the report
    const reportContent = fs.readFileSync(OUTPUT_PATH, 'utf8');
    const report = JSON.parse(reportContent);

    // Debug: Log the report structure
    console.log('Report structure:', JSON.stringify(report, null, 2));

    // Verify that the report contains basic properties
    expect(report).toHaveProperty('summary');
    expect(report).toHaveProperty('endpoints');

    // Verify that our API calls were tracked somewhere in the report
    // Depending on the OpenAPI spec loading, they could be in either endpoints.tested or extraEndpoints
    const testedEndpoints = report.endpoints.tested || [];
    const extraEndpoints = report.extraEndpoints || [];

    // Combined list to check against
    const allTrackedEndpoints = [...testedEndpoints, ...extraEndpoints];

    // Check that both our API endpoints were captured somewhere
    expect(allTrackedEndpoints).toContain('GET /users');
    expect(
      allTrackedEndpoints.some(
        (endpoint) => endpoint === 'GET /users/{id}' || endpoint === 'GET /users/1'
      )
    ).toBe(true);

    // Reset environment variable
    delete process.env.WDIO_WORKER_ID;
  });

  test('should handle missing OpenAPI spec gracefully', async () => {
    const options = {
      // Provide a non-existent path
      openApiPath: path.join(__dirname, 'non-existent-spec.json'),
      outputPath: OUTPUT_PATH,
      logLevel: 'silent',
    };

    const service = new OpenAPICoverageService(options as any, {}, options as any);

    // Should not throw when OpenAPI spec is missing
    await expect(service.before({}, [], {} as Browser)).resolves.not.toThrow();

    // Make API calls that won't be normalized against a spec
    try {
      await apiClient.get('https://jsonplaceholder.typicode.com/users');
    } catch (_e) {
      // Ignore errors
    }

    // Should not throw when generating report without a spec
    await expect(service.after(0, {}, [])).resolves.not.toThrow();

    // Report should still be generated
    expect(fs.existsSync(OUTPUT_PATH)).toBe(true);
  });
});
