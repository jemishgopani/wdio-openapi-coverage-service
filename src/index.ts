import { existsSync, unlinkSync } from 'node:fs';
import type { Services } from '@wdio/types';
import logger from '@wdio/logger';

// Import from our modules
import { apiClient, setupInterceptors } from './interceptors/axios-interceptors.js';
import { ensureTempDirs, COVERAGE_DIR } from './utils/file-utils.js';
import {
  loadOpenApiSpec,
  extractEndpointsFromSpec,
  generatePathPatterns,
  inferPatternsFromRequests,
} from './lib/openapi-processor.js';
import { getAllHitEndpoints, getAllServerErrors } from './lib/endpoint-collector.js';
import { generateCoverageReport } from './lib/report-generator.js';
import {
  TServiceOptions,
  IOpenAPIDocument,
  IServerErrorRecord,
  IPathPattern,
} from './types/index.js';
import { join } from 'node:path';

// Create a logger instance
const log = logger('openapi:coverage-service');

/**
 * Export the axios client for use in tests
 */
export { apiClient };

/**
 * Main service class for OpenAPI coverage tracking
 */
export default class OpenAPICoverageService implements Services.ServiceInstance {
  options: TServiceOptions;
  private specEndpoints: Set<string>;
  private hitEndpoints: Set<string>;
  private endpointErrors: Record<string, IServerErrorRecord>;
  private initialized: boolean = false;
  private apiSpec: IOpenAPIDocument | null = null;
  private workerId: string;
  private hitEndpointsFile: string;
  private errorsFile: string;
  private customPatterns?: IPathPattern[];
  private autoGeneratedPatterns?: IPathPattern[];
  private inferredPatterns?: IPathPattern[];
  private allRequestPaths: Set<string>;
  private patternUpdateInterval: NodeJS.Timeout | null = null;
  private lastPathCount: number = 0;

  constructor(
    options: TServiceOptions,
    _capabilities: WebdriverIO.Capabilities,
    _config: TServiceOptions
  ) {
    this.options = options;
    this.specEndpoints = new Set();
    this.hitEndpoints = new Set<string>();
    this.endpointErrors = {};
    this.apiSpec = null;
    this.allRequestPaths = new Set<string>();

    // Store custom patterns if provided
    this.customPatterns = options.customPatterns || [];

    // Generate a unique worker ID (if not available, create a random one)
    this.workerId =
      process.env.WDIO_WORKER_ID || `worker-${Math.random().toString(36).substring(2, 11)}`;

    // Create worker-specific file paths
    this.hitEndpointsFile = join(COVERAGE_DIR, `endpoints-${this.workerId}.json`);
    this.errorsFile = join(COVERAGE_DIR, `errors-${this.workerId}.json`);

    log.info(`OpenAPI Coverage Service initialized for worker ${this.workerId}`);

    // Ensure temp directories exist
    ensureTempDirs();

    // Setup interceptors ASAP, not waiting for before() hook
    this.setupAxiosInterceptors();

    // Set up pattern learning (enabled by default)
    const enableLearning = this.options.enableDynamicPatternLearning === true; // true by default
    if (this.options.endpointPatternFile) {
      log.info(`Using endpoint pattern file: ${this.options.endpointPatternFile}`);
    } else if (enableLearning) {
      this.setupPatternLearning();
      log.info('Dynamic pattern learning enabled - will analyze API requests to infer patterns');
    } else {
      log.info('Dynamic pattern learning is disabled - using only OpenAPI and custom patterns');
    }
  }

  /**
   * Set up dynamic pattern learning from API requests
   */
  private setupPatternLearning(): void {
    // Skip pattern learning if using endpoint pattern file
    if (this.options.endpointPatternFile) {
      log.info('Using endpoint pattern file - dynamic pattern learning disabled');
      return;
    }

    // Check more frequently for new patterns (every 5 seconds)
    this.patternUpdateInterval = setInterval(() => {
      this.updateInferredPatterns();
    }, 5000); // 5 seconds
  }

  /**
   * Update inferred patterns based on observed API requests
   */
  private updateInferredPatterns(): void {
    // Only update if we have new paths
    if (this.allRequestPaths.size <= this.lastPathCount) {
      return;
    }

    const paths = Array.from(this.allRequestPaths);
    log.info(
      `Updating inferred patterns from ${paths.length} observed API requests (${this.allRequestPaths.size - this.lastPathCount} new)`
    );

    // Generate inferred patterns from the request paths
    const existingPatterns = this.getAllPatterns();
    const newInferredPatterns = inferPatternsFromRequests(paths, existingPatterns);

    if (newInferredPatterns.length > 0) {
      // Log some of the paths that were used to infer patterns (up to 5)
      const samplePaths = paths.slice(0, 5);
      log.info(`Sample paths used for inference: ${samplePaths.join(', ')}`);

      // Update our inferred patterns
      if (!this.inferredPatterns) {
        this.inferredPatterns = newInferredPatterns;
      } else {
        // Merge new patterns with existing ones, avoiding duplicates
        const existingTemplates = new Set(
          this.inferredPatterns.map((p: IPathPattern) => p.template)
        );
        const uniqueNewPatterns = newInferredPatterns.filter(
          (p: IPathPattern) => !existingTemplates.has(p.template)
        );

        if (uniqueNewPatterns.length > 0) {
          this.inferredPatterns = [...this.inferredPatterns, ...uniqueNewPatterns];
          log.info(
            `Added ${uniqueNewPatterns.length} new unique patterns (${this.inferredPatterns.length} total inferred patterns)`
          );
        }
      }

      // Update interceptors with the new patterns
      const allPatterns = this.getAllPatterns();
      log.info(`Using ${allPatterns.length} total patterns for path normalization`);

      setupInterceptors(
        this.hitEndpoints,
        this.endpointErrors,
        this.apiSpec,
        this.workerId,
        this.hitEndpointsFile,
        this.errorsFile,
        allPatterns,
        this.recordRequestPath.bind(this)
      );
    }

    this.lastPathCount = this.allRequestPaths.size;
  }

  /**
   * Record a path from an API request (used by interceptors)
   */
  recordRequestPath(path: string): void {
    if (!path) {
      return;
    }

    // Normalize the path to ensure consistent formatting
    // Remove trailing slashes and ensure leading slash
    const normalizedPath = path.replace(/\/+$/, '');
    if (!normalizedPath) {
      return;
    }

    // Check if this is a new path
    const isNewPath = !this.allRequestPaths.has(normalizedPath);

    // Add to our collection
    this.allRequestPaths.add(normalizedPath);

    // Log when we see new paths (but avoid excessive logging)
    if (isNewPath && this.allRequestPaths.size % 5 === 0) {
      log.debug(`Recorded ${this.allRequestPaths.size} unique API paths for pattern learning`);
    }
  }

  /**
   * Set up Axios interceptors to track API requests and errors
   */
  private setupAxiosInterceptors(): void {
    if (this.initialized) {
      log.warn('Interceptors already set up, skipping');
      return;
    }

    setupInterceptors(
      this.hitEndpoints,
      this.endpointErrors,
      this.apiSpec,
      this.workerId,
      this.hitEndpointsFile,
      this.errorsFile,
      this.getAllPatterns(), // Pass all patterns (custom + auto-generated + inferred)
      this.recordRequestPath.bind(this) // Pass callback to record paths
    );

    this.initialized = true;
  }

  /**
   * Get all path normalization patterns (custom + auto-generated + inferred)
   */
  private getAllPatterns(): IPathPattern[] {
    const allPatterns = [...(this.customPatterns || [])];

    if (this.autoGeneratedPatterns) {
      allPatterns.push(...this.autoGeneratedPatterns);
    }

    if (this.inferredPatterns) {
      allPatterns.push(...this.inferredPatterns);
    }

    return allPatterns;
  }

  /**
   * WebdriverIO before hook
   */
  async before(
    _capabilities: WebdriverIO.Capabilities,
    _specs: string[],
    _browser: WebdriverIO.Browser
  ): Promise<void> {
    log.info(`OpenAPI Coverage Service: before() method called for worker ${this.workerId}`);

    // Ensure interceptors are set up (should already be done in constructor, but just in case)
    this.setupAxiosInterceptors();

    // Only try to load the OpenAPI spec if we don't already have one
    if (!this.apiSpec) {
      this.apiSpec = await loadOpenApiSpec(this.options.openApiPath);

      if (this.apiSpec) {
        // Generate patterns and extract endpoints from the OpenAPI spec
        this.autoGeneratedPatterns = generatePathPatterns(this.apiSpec);
        this.specEndpoints = extractEndpointsFromSpec(this.apiSpec);

        log.info(
          `Generated ${this.autoGeneratedPatterns?.length || 0} patterns from OpenAPI spec with ${this.specEndpoints.size} endpoints`
        );

        // Update interceptors with the new patterns
        setupInterceptors(
          this.hitEndpoints,
          this.endpointErrors,
          this.apiSpec,
          this.workerId,
          this.hitEndpointsFile,
          this.errorsFile,
          this.getAllPatterns(),
          this.recordRequestPath.bind(this)
        );
      } else {
        log.warn('No OpenAPI specification found or loaded');
      }
    }

    // Clean up any previous files for this worker
    if (existsSync(this.hitEndpointsFile)) {
      unlinkSync(this.hitEndpointsFile);
      log.info(`Cleaned up previous hit file: ${this.hitEndpointsFile}`);
    }

    if (existsSync(this.errorsFile)) {
      unlinkSync(this.errorsFile);
      log.info(`Cleaned up previous errors file: ${this.errorsFile}`);
    }
  }

  /**
   * WebdriverIO after hook
   */
  async after(
    _exitCode: number,
    _capabilities: WebdriverIO.Capabilities,
    _specs: string[]
  ): Promise<void> {
    log.info(`OpenAPI Coverage Service: after() method called for worker ${this.workerId}`);

    // Clear any pattern learning intervals
    if (this.patternUpdateInterval) {
      clearInterval(this.patternUpdateInterval);
      this.patternUpdateInterval = null;
    }

    // Determine if this worker should generate the report (usually only one worker should do it)
    // WebdriverIO uses formats like "0-1" where the first number is the spec file index
    // and the second is the worker instance number, or "0" for a single worker
    const isMainWorker =
      !process.env.WDIO_WORKER_ID ||
      process.env.WDIO_WORKER_ID === '0' ||
      process.env.WDIO_WORKER_ID.startsWith('0-');

    if (!isMainWorker) {
      log.info(`Worker ${this.workerId} is not the main worker, skipping report generation`);
      return;
    }

    log.info(`Worker ${this.workerId} is generating the coverage report`);

    // Do one final pattern inference before generating the report
    if (this.allRequestPaths.size > 0) {
      this.updateInferredPatterns();
    }

    // Collect all hit endpoints from all workers
    const hitEndpoints = getAllHitEndpoints(this.hitEndpoints, this.workerId);
    log.info(`Combined total: ${hitEndpoints.length} unique hit endpoints from all workers`);

    // Collect all server errors from all workers
    const allServerErrors = getAllServerErrors(this.endpointErrors);

    // Generate and save the coverage report
    const reportPath = this.options.outputPath || 'api-coverage-report.json';
    generateCoverageReport(
      this.specEndpoints,
      hitEndpoints,
      allServerErrors,
      reportPath,
      this.options.endpointPatternFile !== undefined ? this.options.endpointPatternFile : undefined
    );
  }
}
